[
  {
    "id": 1,
    "name": "check_mr",
    "group": "scripts",
    "description": "\u68c0\u67e5\u5408\u5e76\u5230develop\uff0c\u4f46\u6ca1\u5408\u5e76\u5230rel_2412\u7684mr",
    "command": "from itertools import islice\n\nfrom datetime import datetime, timedelta\nimport gitlab\nfrom tabulate import tabulate\n\n# === \u521d\u59cb\u5316 GitLab \u5ba2\u6237\u7aef ===\nGITLAB_URL = 'https://git-sha.yunsilicon.com'\nPRIVATE_TOKEN = 'qZb5uFi8JfxLNmXnvtWW'  # \u4ece\u73af\u5883\u53d8\u91cf\u8bfb\u53d6 token \u66f4\u5b89\u5168\nPROJECT_PATH = 'yunsilicon-software/meta-cloud'\n\nREVIEWER = 'gongyh'\nSRC_BRANCH = 'develop'\nDEST_BRANCH = 'rel_2412'\n\n# \u65f6\u95f4\u9650\u5236\uff1a\u6700\u8fd1 30 \u5929\ncreated_after = (datetime.utcnow() - timedelta(days=30)).isoformat()\n\ngl = gitlab.Gitlab(GITLAB_URL, private_token=PRIVATE_TOKEN)\nproject = gl.projects.get(PROJECT_PATH)\n\n# === 1. \u672a\u5408\u5e76 MR\uff08\u76ee\u6807 develop\uff0cReviewer \u662f gongyouhua\uff09===\nopen_mrs = project.mergerequests.list(\n    state='opened',\n    target_branch=SRC_BRANCH,\n    created_after=created_after,\n    all=True\n)\nopen_mr_rows = []\nfor mr in open_mrs:\n    reviewers = [r['username'] for r in mr.attributes.get('reviewers', [])]\n    if REVIEWER in reviewers:\n        url = f\"{GITLAB_URL}/{PROJECT_PATH}/-/merge_requests/{mr.iid}\"\n        open_mr_rows.append([mr.iid, mr.title, mr.author['username'], url])\n\nprint(f'\\n[ \u672a\u5408\u5e76 MR | \u76ee\u6807\u5206\u652f: {SRC_BRANCH} | Reviewer: {REVIEWER} | \u6700\u8fd1 30 \u5929\u5185 ]\\n')\nif open_mr_rows:\n    print(tabulate(open_mr_rows, headers=[\"IID\", \"Title\", \"Author\", \"URL\"], tablefmt=\"grid\"))\nelse:\n    print(\"(\u65e0)\")\n\ndef get_recent_commit_messages(ref_name, max_count=500):\n    \"\"\"\u83b7\u53d6\u67d0\u4e2a\u5206\u652f\u7684\u6700\u8fd1 500 \u6761 commit message \u5217\u8868\"\"\"\n    commits_iter = project.commits.list(ref_name=ref_name, iterator=True, per_page=max_count)\n    return [c.message for c in islice(commits_iter, max_count)]\n\nrel_commit_messages = get_recent_commit_messages(DEST_BRANCH, max_count=500)\ndef is_cherry_picked(merge_sha, commit_messages):\n    needle = f\"(cherry picked from commit {merge_sha})\"\n    return any(needle in msg for msg in commit_messages)\n\nmerged_mrs = project.mergerequests.list(\n    state='merged',\n    target_branch=SRC_BRANCH,\n    created_after=created_after,\n    all=True\n)\n\ncherry_miss_rows = []\nfor mr in merged_mrs:\n    reviewers = [r['username'] for r in mr.attributes.get('reviewers', [])]\n    if REVIEWER not in reviewers:\n        continue\n    merge_commit_sha = mr.attributes.get('merge_commit_sha')\n    if merge_commit_sha and not is_cherry_picked(merge_commit_sha, rel_commit_messages):\n        url = f\"{GITLAB_URL}/{PROJECT_PATH}/-/merge_requests/{mr.iid}\"\n        cherry_miss_rows.append([mr.iid, mr.title, merge_commit_sha[:7], url])\n\nprint(f'\\n[ \u5df2\u5408\u5e76 MR \u5230 {SRC_BRANCH} \u4f46\u672a cherry-pick \u5230 {DEST_BRANCH} | Reviewer: {REVIEWER} | \u6700\u8fd1 30 \u5929\u5185 ]\\n')\nif cherry_miss_rows:\n    print(tabulate(cherry_miss_rows, headers=[\"IID\", \"Title\", \"Merged SHA\", \"URL\"], tablefmt=\"grid\"))\nelse:\n    print(\"(\u65e0)\")",
    "copy_count": 0
  },
  {
    "id": 2,
    "name": "update_dpuagent_image",
    "group": "scripts",
    "description": "\u66f4\u65b0\u5305\u542bdpuagent\u9879\u76ee\u6700\u65b0\u7684docker\u955c\u50cf",
    "command": "import docker\nimport re\n\nclient = docker.from_env()\n\ncontainer_name = \"wubl-dev-ubuntu8899\"\nrepo_base = \"harbor.yunsilicon.com/sw/wubl/wubl-dev\"\n\n# === Step 1: \u6267\u884c git pull ===\ncontainer = client.containers.get(container_name)\ncommand = \"sh -c 'cd /home/wubl/meta-cloud && git pull'\"\nresult = container.exec_run(command, stdout=True, stderr=True)\nprint(\"Step 1 - Git Pull\")\nprint(\"Exit Code:\", result.exit_code)\nprint(\"Output:\\n\", result.output.decode())\n\n# === Step 2: \u67e5\u627e\u5df2\u6709 tag \u4e2d\u6700\u5927\u7684\u7248\u672c\u53f7 ===\nprint(\"\\nStep 2 - \u67e5\u627e\u6700\u65b0 tag\")\nimages = client.images.list(name=repo_base)\nexisting_tags = []\n\nfor image in images:\n    for tag in image.tags:\n        if tag.startswith(repo_base + \":\"):\n            match = re.match(rf\"{re.escape(repo_base)}:v(\\d+)\", tag)\n            if match:\n                existing_tags.append(int(match.group(1)))\n\nif not existing_tags:\n    raise RuntimeError(\"\u672a\u627e\u5230\u4efb\u4f55\u5df2\u6709 tag\uff0c\u65e0\u6cd5\u8986\u76d6\u6700\u65b0\u7248\u672c\u3002\")\n\nlatest_version = max(existing_tags)\nlatest_tag = f\"v{latest_version}\"\nprint(f\"Latest version tag to overwrite: {repo_base}:{latest_tag}\")\n\n# === Step 3: \u8986\u76d6 commit \u955c\u50cf ===\nprint(\"\\nStep 3 - Commit \u5bb9\u5668\u8986\u76d6\u955c\u50cf\")  # MODIFIED\nimage = container.commit(repository=repo_base, tag=latest_tag)  # MODIFIED\nprint(f\"Overwritten image: {image.tags[0]}\")\n\n# === Step 4: Push \u5230 Harbor \u4ed3\u5e93 ===\nprint(\"\\nStep 4 - Push \u5230 Harbor\")  # MODIFIED\nfor line in client.images.push(repo_base, tag=latest_tag, stream=True, decode=True):  # MODIFIED\n    print(line)",
    "copy_count": 0
  },
  {
    "id": 3,
    "name": "update_project_by_image",
    "group": "scripts",
    "description": "\u4f7f\u7528\u5305\u542bdpuagent\u9879\u76ee\u6700\u65b0\u7684docker\u955c\u50cf\u6765\u66f4\u65b0\u9879\u76ee",
    "command": "import docker\nimport requests\nimport re\nimport time\nimport urllib3\n\nurllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n\nharbor_url = \"harbor.yunsilicon.com\"\nproject = \"sw\"\nrepo_path = \"wubl/wubl-dev\"\nharbor_auth = (\"wubl\", \"199610wad14s..\")  # \u79c1\u6709\u4ed3\u5e93\u7528\u6237\u540d\u5bc6\u7801\nrepo = f\"{project}/{repo_path}\"\nrepo_base = f\"{harbor_url}/{repo}\"\n\nharbor_api = f\"https://{harbor_url}/api/repositories/{repo}/tags?detail=true\"\n\nclient = docker.from_env()\n\ndef get_latest_tag():\n    print(\"Querying Harbor (1.x API) for latest tag...\")\n    resp = requests.get(harbor_api, auth=harbor_auth, verify=False)\n    resp.raise_for_status()\n    tags = resp.json()\n\n    version_numbers = []\n    pattern = re.compile(r\"v(\\d+)$\")\n\n    for tag in tags:\n        tag_name = tag[\"name\"]\n        print(f\"Found tag: {tag_name}\")  # \u8c03\u8bd5\u8f93\u51fa\n        m = pattern.match(tag_name)\n        if m:\n            version_numbers.append(int(m.group(1)))\n\n    if not version_numbers:\n        raise RuntimeError(\"No valid version tags found in Harbor repo\")\n\n    latest_version = max(version_numbers)\n    latest_tag = f\"v{latest_version}\"\n    print(f\"Latest tag on Harbor: {latest_tag}\")\n    return latest_tag\n\ndef image_exists_locally(image_full_name):\n    try:\n        client.images.get(image_full_name)\n        return True\n    except docker.errors.ImageNotFound:\n        return False\n\ndef pull_image(image_full_name):\n    print(f\"Pulling image {image_full_name} from Harbor...\")\n    client.images.pull(image_full_name)\n    print(\"Image pulled successfully.\")\n\ndef run_container(image_name):\n    print(f\"Starting container from image {image_name}...\")\n    container = client.containers.run(\n        image_name,\n        detach=True,\n        tty=True,\n        name=None\n    )\n    time.sleep(2)  # \u7b49\u5f85\u5bb9\u5668\u542f\u52a8\u7a33\u5b9a\n    return container\n\ndef exec_commands(container, commands):\n    for cmd in commands:\n        print(f\"Running command: {cmd}\")\n        result = container.exec_run(f\"sh -c '{cmd}'\", stdout=True, stderr=True)\n        output = result.output.decode()\n        print(output)\n        if result.exit_code != 0:\n            print(f\"Warning: Command '{cmd}' exited with code {result.exit_code}\")\n\ndef clean_old_images(repo_base, keep_tag):\n    \"\"\"\n    \u5220\u9664 repo_base \u4ed3\u5e93\u4e2d\uff0c\u9664\u4e86 keep_tag \u4ee5\u5916\u7684\u8001\u955c\u50cf\u3002\n    \"\"\"\n    print(f\"Cleaning old images for {repo_base}, keep tag: {keep_tag}\")\n    images = client.images.list(name=repo_base)\n    \n    pattern = re.compile(r\"v(\\d+)$\")\n    images_to_delete = []\n    \n    for image in images:\n        # image.tags \u662f\u4e00\u4e2a\u5217\u8868\uff0c\u53ef\u80fd\u6709\u591a\u4e2atag\n        # \u627e\u51fa\u5c5e\u4e8erepo_base\u4e14\u6709v\u6570\u5b57tag\u7684tag\n        tags = [t for t in image.tags if t.startswith(repo_base + \":\")]\n        for tag in tags:\n            tag_version = tag.split(\":\")[-1]\n            if tag_version != keep_tag:\n                m = pattern.match(tag_version)\n                if m:\n                    images_to_delete.append(image.id)\n    \n    images_to_delete = list(set(images_to_delete))  # \u53bb\u91cd\n    print(f\"Found {len(images_to_delete)} old images to remove.\")\n    \n    for img_id in images_to_delete:\n        try:\n            print(f\"Removing image {img_id} ...\")\n            client.images.remove(img_id, force=True)\n        except Exception as e:\n            print(f\"Failed to remove image {img_id}: {e}\")\n\ndef main():\n    latest_tag = get_latest_tag()\n    image_full_name = f\"{repo_base}:{latest_tag}\"\n\n    pull_image(image_full_name)\n\n    container = run_container(image_full_name)\n\n    cmds = [\n        \"cd /home/wubl/meta-cloud && git filter-repo --force --subdirectory-filter apps/dpu/dpuagent\",\n        \"ssh-keyscan github.com >> /root/.ssh/known_hosts\",\n        \"cd /home/wubl/meta-cloud && git remote add origin git@github.com:Ber1in/dpuagent.git || true\",\n        \"cd /home/wubl/meta-cloud && git checkout -b master\",\n        \"cd /home/wubl/meta-cloud && git push origin master\"\n    ]\n\n    exec_commands(container, cmds)\n\n    print(\"Commands finished. Stopping and removing container...\")\n    container.stop()\n    container.remove()\n    print(\"Container stopped and removed.\")\n\n    # \u6e05\u7406\u65e7\u955c\u50cf\uff0c\u4fdd\u7559\u6700\u65b0\u7684\u955c\u50cf\n    clean_old_images(repo_base, latest_tag)\n\n\nif __name__ == \"__main__\":\n    main()",
    "copy_count": 0
  },
  {
    "id": 4,
    "name": "clean_dpu",
    "group": "scripts",
    "description": "\u6e05\u7406dpu\uff0c\u7528\u4e8e\u6a21\u62dfsoc\u91cd\u542f",
    "command": "cat << 'EOF' > /root/wubl/simulate_cold_restart_of_soc.py\nimport os\nfrom dpuagent.services.vsdk_service import VsdkService\n\nRECOVERY_LOCK_FILE = \"/var/run/dpuagent/recovered.lock\"\nTEMP_RECORD_FILENAME = '/var/run/dpuagent/temporary_records.log'\n\nvsdk_svc = VsdkService()\nblk_used, xsc_used, unused_uuids = vsdk_svc.get_uuid_usage()\nprint(f\"blk used uuid: {blk_used}, xsc net used uuid: {xsc_used}\")\nprint(\"-----------------------------\")\nprint(\"start clean xscnet\")\nfor uuid in xsc_used:\n    if uuid == 0:\n        continue\n    print(f\"delete xscnet {uuid}\")\n    vsdk_svc.delete_xscnet(uuid)\n\nprint(\"-----------------------------\")\nprint(\"start clean blk\")\nfor uuid in blk_used:\n    print(f\"delete blk {uuid}\")\n    vsdk_svc.delete_vblk(uuid)\n\nprint(\"-----------------------------\")\nprint(\"start clean bdev\")\nbdevs = vsdk_svc.bdev_get_bdevs()\nfor bdev in bdevs:\n    if bdev[\"product_name\"] == \"AIO disk\":\n        print(f\"delete aio bdev {bdev['name']}\")\n        vsdk_svc.delete_bdev_aio(bdev[\"name\"])\n    if bdev[\"product_name\"] == \"NVMe disk\":\n        print(f\"detach virtblk {bdev['name']}\")\n        controller_name = bdev[\"name\"].rsplit('n', 1)[0]\n        vsdk_svc.bdev_nvme_detach_controller(controller_name)\n\nif os.path.exists(RECOVERY_LOCK_FILE):\n    print(\"-----------------------------\")\n    print(f\"delete recovered lock {RECOVERY_LOCK_FILE}\")\n    os.remove(RECOVERY_LOCK_FILE)\nprint(\"-----------------------------\")\n\nif os.path.exists(TEMP_RECORD_FILENAME):\n    print(\"-----------------------------\")\n    print(f\"delete temp record file {TEMP_RECORD_FILENAME}\")\n    os.remove(TEMP_RECORD_FILENAME)\nprint(\"-----------------------------\")\nEOF\n\npython3 /root/wubl/simulate_cold_restart_of_soc.py\nip link delete dev dhcp1\nsystemctl restart ovs-dpdk\n\necho \"Successfully cleaned up all resources.\"",
    "copy_count": 0
  },
  {
    "id": 5,
    "name": "sshfs_mount_auto",
    "group": "scripts",
    "description": "\u4f7f\u7528ssfs\u6302\u8f7d\u5171\u4eab\u76ee\u5f55/auto",
    "command": "mkdir -p /auto\nsshfs wubl@10.0.3.248:/auto /auto",
    "copy_count": 0
  }
]